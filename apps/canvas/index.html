<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Glyph Canvas</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      background: #000;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    
    #canvas {
      display: block;
      cursor: crosshair;
    }
    
    .toolbar {
      position: fixed;
      top: 1rem;
      left: 1rem;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 0.5rem;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
      color: white;
      z-index: 100;
    }
    
    .tool-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .tool-group label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #94a3b8;
    }
    
    .brush-selector {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.5rem;
    }
    
    .brush-btn {
      width: 40px;
      height: 40px;
      border: 2px solid #334155;
      background: #1e293b;
      border-radius: 0.375rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
    }
    
    .brush-btn:hover {
      border-color: #8b5cf6;
    }
    
    .brush-btn.active {
      background: #8b5cf6;
      border-color: #8b5cf6;
    }
    
    input[type="range"] {
      width: 150px;
    }
    
    input[type="color"] {
      width: 100%;
      height: 40px;
      border: 2px solid #334155;
      border-radius: 0.375rem;
      cursor: pointer;
    }
    
    .actions {
      display: flex;
      gap: 0.5rem;
    }
    
    .btn {
      padding: 0.5rem 1rem;
      background: #475569;
      border: none;
      border-radius: 0.375rem;
      color: white;
      cursor: pointer;
      font-size: 0.875rem;
    }
    
    .btn:hover {
      background: #64748b;
    }
    
    .btn.primary {
      background: #8b5cf6;
    }
    
    .btn.primary:hover {
      background: #7c3aed;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div class="toolbar">
    <div class="tool-group">
      <label>Brush</label>
      <div class="brush-selector">
        <button class="brush-btn active" data-brush="circle">●</button>
        <button class="brush-btn" data-brush="fractal">❋</button>
        <button class="brush-btn" data-brush="spray">⊛</button>
        <button class="brush-btn" data-brush="glow">◉</button>
        <button class="brush-btn" data-brush="lightning">⚡</button>
        <button class="brush-btn" data-brush="stars">✦</button>
      </div>
    </div>
    
    <div class="tool-group">
      <label>Size: <span id="sizeLabel">20</span></label>
      <input type="range" id="sizeSlider" min="1" max="100" value="20">
    </div>
    
    <div class="tool-group">
      <label>Opacity: <span id="opacityLabel">100</span>%</label>
      <input type="range" id="opacitySlider" min="0" max="100" value="100">
    </div>
    
    <div class="tool-group">
      <label>Color</label>
      <input type="color" id="colorPicker" value="#8b5cf6">
    </div>
    
    <div class="actions">
      <button class="btn" id="clear">Clear</button>
      <button class="btn primary" id="save">Save</button>
    </div>
  </div>

  <script type="module">
    // Glyph Canvas - GlyphOS
    
    const canvas = document.getElementById('canvas')
    const ctx = canvas.getContext('2d', { alpha: false })
    
    // Resize canvas to window
    function resizeCanvas() {
      canvas.width = window.innerWidth
      canvas.height = window.innerHeight
      ctx.fillStyle = '#000'
      ctx.fillRect(0, 0, canvas.width, canvas.height)
    }
    
    resizeCanvas()
    window.addEventListener('resize', resizeCanvas)
    
    // Drawing state
    let isDrawing = false
    let currentBrush = 'circle'
    let brushSize = 20
    let brushOpacity = 1
    let brushColor = '#8b5cf6'
    let lastX = 0
    let lastY = 0
    
    // Brush implementations
    const brushes = {
      circle(x, y) {
        ctx.globalAlpha = brushOpacity
        ctx.fillStyle = brushColor
        ctx.beginPath()
        ctx.arc(x, y, brushSize / 2, 0, Math.PI * 2)
        ctx.fill()
      },
      
      fractal(x, y) {
        ctx.globalAlpha = brushOpacity
        ctx.strokeStyle = brushColor
        ctx.lineWidth = 1
        
        // Draw fractal pattern
        const iterations = 5
        const branches = 6
        
        for (let i = 0; i < iterations; i++) {
          const radius = brushSize * (1 - i / iterations)
          for (let j = 0; j < branches; j++) {
            const angle = (Math.PI * 2 * j) / branches + Math.random() * 0.5
            const x2 = x + Math.cos(angle) * radius
            const y2 = y + Math.sin(angle) * radius
            
            ctx.beginPath()
            ctx.moveTo(x, y)
            ctx.lineTo(x2, y2)
            ctx.stroke()
          }
        }
      },
      
      spray(x, y) {
        ctx.globalAlpha = brushOpacity * 0.3
        ctx.fillStyle = brushColor
        
        const density = brushSize
        for (let i = 0; i < density; i++) {
          const angle = Math.random() * Math.PI * 2
          const radius = Math.random() * brushSize
          const px = x + Math.cos(angle) * radius
          const py = y + Math.sin(angle) * radius
          
          ctx.fillRect(px, py, 2, 2)
        }
      },
      
      glow(x, y) {
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, brushSize)
        gradient.addColorStop(0, brushColor)
        gradient.addColorStop(1, 'transparent')
        
        ctx.globalAlpha = brushOpacity
        ctx.fillStyle = gradient
        ctx.fillRect(x - brushSize, y - brushSize, brushSize * 2, brushSize * 2)
      },
      
      lightning(x, y) {
        ctx.globalAlpha = brushOpacity
        ctx.strokeStyle = brushColor
        ctx.lineWidth = 2
        
        // Draw lightning bolts
        for (let i = 0; i < 5; i++) {
          const angle = Math.random() * Math.PI * 2
          let px = x
          let py = y
          
          ctx.beginPath()
          ctx.moveTo(px, py)
          
          for (let j = 0; j < 10; j++) {
            const dist = brushSize / 10
            const offset = (Math.random() - 0.5) * brushSize * 0.5
            px += Math.cos(angle) * dist + Math.cos(angle + Math.PI / 2) * offset
            py += Math.sin(angle) * dist + Math.sin(angle + Math.PI / 2) * offset
            ctx.lineTo(px, py)
          }
          
          ctx.stroke()
        }
      },
      
      stars(x, y) {
        ctx.globalAlpha = brushOpacity
        ctx.fillStyle = brushColor
        
        const starCount = Math.floor(brushSize / 5)
        for (let i = 0; i < starCount; i++) {
          const angle = Math.random() * Math.PI * 2
          const radius = Math.random() * brushSize
          const sx = x + Math.cos(angle) * radius
          const sy = y + Math.sin(angle) * radius
          const size = Math.random() * 3 + 1
          
          // Draw star
          ctx.save()
          ctx.translate(sx, sy)
          ctx.rotate(Math.random() * Math.PI * 2)
          
          ctx.beginPath()
          for (let j = 0; j < 5; j++) {
            const a = (Math.PI * 2 * j) / 5
            const r = j % 2 === 0 ? size : size / 2
            const px = Math.cos(a) * r
            const py = Math.sin(a) * r
            if (j === 0) ctx.moveTo(px, py)
            else ctx.lineTo(px, py)
          }
          ctx.closePath()
          ctx.fill()
          
          ctx.restore()
        }
      }
    }
    
    // Drawing
    function draw(x, y) {
      if (!isDrawing) return
      
      // Interpolate between last and current position
      const dist = Math.hypot(x - lastX, y - lastY)
      const steps = Math.max(1, Math.floor(dist / 5))
      
      for (let i = 0; i <= steps; i++) {
        const t = i / steps
        const ix = lastX + (x - lastX) * t
        const iy = lastY + (y - lastY) * t
        
        brushes[currentBrush](ix, iy)
      }
      
      lastX = x
      lastY = y
      
      ctx.globalAlpha = 1
    }
    
    // Mouse events
    canvas.addEventListener('mousedown', (e) => {
      isDrawing = true
      lastX = e.clientX
      lastY = e.clientY
      draw(e.clientX, e.clientY)
    })
    
    canvas.addEventListener('mousemove', (e) => {
      draw(e.clientX, e.clientY)
    })
    
    canvas.addEventListener('mouseup', () => {
      isDrawing = false
    })
    
    canvas.addEventListener('mouseleave', () => {
      isDrawing = false
    })
    
    // Touch events
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault()
      const touch = e.touches[0]
      isDrawing = true
      lastX = touch.clientX
      lastY = touch.clientY
      draw(touch.clientX, touch.clientY)
    })
    
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault()
      const touch = e.touches[0]
      draw(touch.clientX, touch.clientY)
    })
    
    canvas.addEventListener('touchend', () => {
      isDrawing = false
    })
    
    // UI Controls
    document.querySelectorAll('.brush-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.brush-btn').forEach(b => b.classList.remove('active'))
        btn.classList.add('active')
        currentBrush = btn.dataset.brush
      })
    })
    
    document.getElementById('sizeSlider').addEventListener('input', (e) => {
      brushSize = parseInt(e.target.value)
      document.getElementById('sizeLabel').textContent = brushSize
    })
    
    document.getElementById('opacitySlider').addEventListener('input', (e) => {
      brushOpacity = parseInt(e.target.value) / 100
      document.getElementById('opacityLabel').textContent = e.target.value
    })
    
    document.getElementById('colorPicker').addEventListener('input', (e) => {
      brushColor = e.target.value
    })
    
    document.getElementById('clear').addEventListener('click', () => {
      if (confirm('Clear canvas?')) {
        ctx.fillStyle = '#000'
        ctx.fillRect(0, 0, canvas.width, canvas.height)
      }
    })
    
    document.getElementById('save').addEventListener('click', async () => {
      canvas.toBlob(async (blob) => {
        const timestamp = Date.now()
        await OS.storage.blob.put(`canvas-${timestamp}.png`, blob, {
          type: 'image/png'
        })
        
        // Also trigger download
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = `glyph-canvas-${timestamp}.png`
        a.click()
        URL.revokeObjectURL(url)
        
        alert('Saved!')
      })
    })
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'c' && (e.metaKey || e.ctrlKey)) {
        document.getElementById('clear').click()
      } else if (e.key === 's' && (e.metaKey || e.ctrlKey)) {
        e.preventDefault()
        document.getElementById('save').click()
      }
    })
  </script>
</body>
</html>
