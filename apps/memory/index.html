<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Memory Graph</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #0f172a;
      color: #e2e8f0;
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .header {
      padding: 1rem;
      background: #1e293b;
      border-bottom: 1px solid #334155;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .title-section {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    
    .title {
      font-size: 1.25rem;
      font-weight: 600;
    }
    
    .stats {
      display: flex;
      gap: 1.5rem;
      font-size: 0.875rem;
      color: #94a3b8;
    }
    
    .stat {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .stat-value {
      color: #ec4899;
      font-weight: 600;
    }
    
    .controls {
      display: flex;
      gap: 0.5rem;
    }
    
    .btn {
      padding: 0.5rem 1rem;
      background: #334155;
      border: none;
      border-radius: 0.375rem;
      color: #e2e8f0;
      cursor: pointer;
      font-size: 0.875rem;
      transition: background 0.2s;
    }
    
    .btn:hover {
      background: #475569;
    }
    
    .btn.primary {
      background: #ec4899;
    }
    
    .btn.primary:hover {
      background: #db2777;
    }
    
    .container {
      flex: 1;
      display: flex;
      position: relative;
      overflow: hidden;
    }
    
    .sidebar {
      width: 300px;
      background: #1e293b;
      border-right: 1px solid #334155;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    
    .sidebar-section {
      padding: 1rem;
      border-bottom: 1px solid #334155;
    }
    
    .section-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: #64748b;
      margin-bottom: 0.75rem;
    }
    
    .search-box {
      width: 100%;
      padding: 0.5rem;
      background: #0f172a;
      border: 1px solid #334155;
      border-radius: 0.375rem;
      color: #e2e8f0;
      font-size: 0.875rem;
    }
    
    .search-box:focus {
      outline: none;
      border-color: #ec4899;
    }
    
    .filter-group {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    
    .filter-chip {
      padding: 0.375rem 0.75rem;
      background: #334155;
      border: 1px solid #475569;
      border-radius: 1rem;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .filter-chip:hover {
      background: #475569;
    }
    
    .filter-chip.active {
      background: #ec4899;
      border-color: #ec4899;
    }
    
    .node-list {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }
    
    .node-item {
      padding: 0.75rem;
      background: #0f172a;
      border-radius: 0.375rem;
      margin-bottom: 0.5rem;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .node-item:hover {
      background: #1e293b;
      transform: translateX(4px);
    }
    
    .node-item.selected {
      border: 1px solid #ec4899;
    }
    
    .node-type {
      display: inline-block;
      padding: 0.125rem 0.5rem;
      background: #334155;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      margin-bottom: 0.5rem;
    }
    
    .node-title {
      font-weight: 500;
      margin-bottom: 0.25rem;
    }
    
    .node-preview {
      font-size: 0.75rem;
      color: #64748b;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    
    #graph {
      flex: 1;
      position: relative;
      background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
    }
    
    .graph-overlay {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: rgba(30, 41, 59, 0.9);
      backdrop-filter: blur(10px);
      border-radius: 0.5rem;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      z-index: 10;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.75rem;
    }
    
    .legend-color {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }
    
    .ai-panel {
      position: absolute;
      bottom: 1rem;
      left: 1rem;
      right: 1rem;
      background: rgba(30, 41, 59, 0.95);
      backdrop-filter: blur(10px);
      border: 1px solid #334155;
      border-radius: 0.5rem;
      padding: 1rem;
      display: none;
    }
    
    .ai-panel.active {
      display: block;
    }
    
    .ai-input {
      width: 100%;
      padding: 0.75rem;
      background: #0f172a;
      border: 1px solid #334155;
      border-radius: 0.375rem;
      color: #e2e8f0;
      resize: none;
      font-family: inherit;
    }
    
    .ai-response {
      margin-top: 1rem;
      padding: 1rem;
      background: #0f172a;
      border-radius: 0.375rem;
      line-height: 1.5;
    }
    
    .loading {
      display: inline-block;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="title-section">
      <div class="title">🧠 Memory Graph</div>
      <div class="stats">
        <div class="stat">
          <span>Nodes:</span>
          <span class="stat-value" id="nodeCount">0</span>
        </div>
        <div class="stat">
          <span>Connections:</span>
          <span class="stat-value" id="edgeCount">0</span>
        </div>
        <div class="stat">
          <span>Apps:</span>
          <span class="stat-value" id="appCount">0</span>
        </div>
      </div>
    </div>
    <div class="controls">
      <button class="btn" id="syncBtn">Sync Apps</button>
      <button class="btn" id="aiBtn">AI Analysis</button>
      <button class="btn" id="exportBtn">Export</button>
      <button class="btn primary" id="addNodeBtn">Add Node</button>
    </div>
  </div>
  
  <div class="container">
    <div class="sidebar">
      <div class="sidebar-section">
        <div class="section-title">Search</div>
        <input type="text" class="search-box" id="searchBox" placeholder="Search nodes...">
      </div>
      
      <div class="sidebar-section">
        <div class="section-title">Filter by Type</div>
        <div class="filter-group">
          <div class="filter-chip active" data-type="all">All</div>
          <div class="filter-chip" data-type="note">Notes</div>
          <div class="filter-chip" data-type="canvas">Canvas</div>
          <div class="filter-chip" data-type="chat">Chat</div>
          <div class="filter-chip" data-type="room">Room</div>
          <div class="filter-chip" data-type="custom">Custom</div>
        </div>
      </div>
      
      <div class="node-list" id="nodeList"></div>
    </div>
    
    <div id="graph">
      <canvas id="graphCanvas"></canvas>
      
      <div class="graph-overlay">
        <div class="section-title">Legend</div>
        <div class="legend-item">
          <div class="legend-color" style="background: #3b82f6;"></div>
          <span>Notes</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #8b5cf6;"></div>
          <span>Canvas</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #f59e0b;"></div>
          <span>Chat</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #10b981;"></div>
          <span>Room</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #ec4899;"></div>
          <span>Custom</span>
        </div>
      </div>
      
      <div class="ai-panel" id="aiPanel">
        <textarea 
          class="ai-input" 
          id="aiInput" 
          placeholder="Ask about your knowledge graph... (e.g., 'What are my current research threads?')"
          rows="2"
        ></textarea>
        <div class="ai-response" id="aiResponse"></div>
      </div>
    </div>
  </div>

  <script type="module">
    // Memory Graph - GlyphOS
    
    const canvas = document.getElementById('graphCanvas')
    const ctx = canvas.getContext('2d')
    
    let nodes = []
    let edges = []
    let selectedNode = null
    let hoveredNode = null
    let camera = { x: 0, y: 0, zoom: 1 }
    let isDragging = false
    let dragStart = { x: 0, y: 0 }
    
    // Node types and colors
    const nodeTypes = {
      note: { color: '#3b82f6', icon: '📝' },
      canvas: { color: '#8b5cf6', icon: '🎨' },
      chat: { color: '#f59e0b', icon: '💬' },
      room: { color: '#10b981', icon: '👥' },
      custom: { color: '#ec4899', icon: '⭐' }
    }
    
    // Resize canvas
    function resizeCanvas() {
      const container = document.getElementById('graph')
      canvas.width = container.clientWidth
      canvas.height = container.clientHeight
      render()
    }
    
    resizeCanvas()
    window.addEventListener('resize', resizeCanvas)
    
    // Physics simulation
    class ForceSimulation {
      constructor(nodes, edges) {
        this.nodes = nodes
        this.edges = edges
        this.alpha = 1
        this.alphaDecay = 0.02
      }
      
      tick() {
        // Apply forces
        this.applyLinkForce()
        this.applyChargeForce()
        this.applyCenterForce()
        
        // Update positions
        this.nodes.forEach(node => {
          node.vx *= 0.9
          node.vy *= 0.9
          node.x += node.vx
          node.y += node.vy
        })
        
        this.alpha *= (1 - this.alphaDecay)
        return this.alpha > 0.01
      }
      
      applyLinkForce() {
        this.edges.forEach(edge => {
          const source = this.nodes.find(n => n.id === edge.source)
          const target = this.nodes.find(n => n.id === edge.target)
          
          if (!source || !target) return
          
          const dx = target.x - source.x
          const dy = target.y - source.y
          const dist = Math.sqrt(dx * dx + dy * dy) || 1
          const force = (dist - 100) * 0.01
          
          const fx = (dx / dist) * force
          const fy = (dy / dist) * force
          
          source.vx += fx
          source.vy += fy
          target.vx -= fx
          target.vy -= fy
        })
      }
      
      applyChargeForce() {
        for (let i = 0; i < this.nodes.length; i++) {
          for (let j = i + 1; j < this.nodes.length; j++) {
            const a = this.nodes[i]
            const b = this.nodes[j]
            
            const dx = b.x - a.x
            const dy = b.y - a.y
            const dist = Math.sqrt(dx * dx + dy * dy) || 1
            
            const force = -30 / (dist * dist)
            const fx = (dx / dist) * force
            const fy = (dy / dist) * force
            
            a.vx += fx
            a.vy += fy
            b.vx -= fx
            b.vy -= fy
          }
        }
      }
      
      applyCenterForce() {
        const cx = canvas.width / 2
        const cy = canvas.height / 2
        
        this.nodes.forEach(node => {
          node.vx += (cx - node.x) * 0.001
          node.vy += (cy - node.y) * 0.001
        })
      }
    }
    
    let simulation = null
    
    // Sync data from other apps
    async function syncFromApps() {
      try {
        nodes = []
        edges = []
        
        // Query Notes app
        try {
          const notes = await OS.ipc.call('com.glyphd.notes', 'getAllNotes')
          notes.forEach(note => {
            nodes.push({
              id: `note-${note.id}`,
              type: 'note',
              title: note.title || 'Untitled',
              content: note.content,
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              vx: 0,
              vy: 0,
              timestamp: note.updatedAt
            })
          })
        } catch (e) {
          console.log('Notes app not available')
        }
        
        // Query Canvas app
        try {
          const canvases = await OS.ipc.call('com.glyphd.canvas', 'listCanvases')
          canvases.forEach(c => {
            nodes.push({
              id: `canvas-${c.id}`,
              type: 'canvas',
              title: c.name,
              content: '',
              x: Math.random() * canvas.width,
              y: Math.random() * canvas.height,
              vx: 0,
              vy: 0,
              timestamp: c.created
            })
          })
        } catch (e) {
          console.log('Canvas app not available')
        }
        
        // Auto-connect nodes with similar content
        for (let i = 0; i < nodes.length; i++) {
          for (let j = i + 1; j < nodes.length; j++) {
            const similarity = computeSimilarity(nodes[i], nodes[j])
            if (similarity > 0.3) {
              edges.push({
                source: nodes[i].id,
                target: nodes[j].id,
                weight: similarity
              })
            }
          }
        }
        
        // Start physics simulation
        simulation = new ForceSimulation(nodes, edges)
        animate()
        
        updateStats()
        renderNodeList()
        
      } catch (error) {
        console.error('Sync failed:', error)
      }
    }
    
    // Compute similarity between nodes
    function computeSimilarity(a, b) {
      const aWords = (a.title + ' ' + a.content).toLowerCase().split(/\s+/)
      const bWords = (b.title + ' ' + b.content).toLowerCase().split(/\s+/)
      
      const aSet = new Set(aWords)
      const bSet = new Set(bWords)
      
      const intersection = [...aSet].filter(w => bSet.has(w)).length
      const union = new Set([...aSet, ...bSet]).size
      
      return intersection / union
    }
    
    // Animation loop
    function animate() {
      if (simulation && simulation.tick()) {
        render()
        requestAnimationFrame(animate)
      } else {
        render()
      }
    }
    
    // Render graph
    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height)
      
      ctx.save()
      ctx.translate(camera.x, camera.y)
      ctx.scale(camera.zoom, camera.zoom)
      
      // Draw edges
      edges.forEach(edge => {
        const source = nodes.find(n => n.id === edge.source)
        const target = nodes.find(n => n.id === edge.target)
        
        if (!source || !target) return
        
        ctx.beginPath()
        ctx.moveTo(source.x, source.y)
        ctx.lineTo(target.x, target.y)
        ctx.strokeStyle = `rgba(148, 163, 184, ${edge.weight * 0.3})`
        ctx.lineWidth = edge.weight * 2
        ctx.stroke()
      })
      
      // Draw nodes
      nodes.forEach(node => {
        const config = nodeTypes[node.type]
        const isSelected = selectedNode === node.id
        const isHovered = hoveredNode === node.id
        
        // Outer ring for selection/hover
        if (isSelected || isHovered) {
          ctx.beginPath()
          ctx.arc(node.x, node.y, 32, 0, Math.PI * 2)
          ctx.strokeStyle = isSelected ? '#ec4899' : '#64748b'
          ctx.lineWidth = 2
          ctx.stroke()
        }
        
        // Node circle
        ctx.beginPath()
        ctx.arc(node.x, node.y, 24, 0, Math.PI * 2)
        ctx.fillStyle = config.color
        ctx.fill()
        
        // Icon
        ctx.font = '20px serif'
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
        ctx.fillText(config.icon, node.x, node.y)
        
        // Label
        if (isHovered || isSelected) {
          ctx.font = '12px -apple-system, sans-serif'
          ctx.fillStyle = '#e2e8f0'
          ctx.textAlign = 'center'
          ctx.textBaseline = 'top'
          ctx.fillText(node.title.slice(0, 20), node.x, node.y + 30)
        }
      })
      
      ctx.restore()
    }
    
    // Mouse interaction
    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect()
      return {
        x: (e.clientX - rect.left - camera.x) / camera.zoom,
        y: (e.clientY - rect.top - camera.y) / camera.zoom
      }
    }
    
    function findNodeAt(x, y) {
      return nodes.find(node => {
        const dx = node.x - x
        const dy = node.y - y
        return Math.sqrt(dx * dx + dy * dy) < 24
      })
    }
    
    canvas.addEventListener('mousedown', (e) => {
      const pos = getMousePos(e)
      const node = findNodeAt(pos.x, pos.y)
      
      if (node) {
        selectedNode = node.id
        renderNodeList()
      } else {
        isDragging = true
        dragStart = { x: e.clientX - camera.x, y: e.clientY - camera.y }
      }
      
      render()
    })
    
    canvas.addEventListener('mousemove', (e) => {
      if (isDragging) {
        camera.x = e.clientX - dragStart.x
        camera.y = e.clientY - dragStart.y
        render()
      } else {
        const pos = getMousePos(e)
        const node = findNodeAt(pos.x, pos.y)
        hoveredNode = node ? node.id : null
        canvas.style.cursor = node ? 'pointer' : 'default'
        render()
      }
    })
    
    canvas.addEventListener('mouseup', () => {
      isDragging = false
    })
    
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault()
      const delta = e.deltaY > 0 ? 0.9 : 1.1
      camera.zoom = Math.max(0.5, Math.min(2, camera.zoom * delta))
      render()
    })
    
    // Update stats
    function updateStats() {
      document.getElementById('nodeCount').textContent = nodes.length
      document.getElementById('edgeCount').textContent = edges.length
      
      const apps = new Set(nodes.map(n => n.type))
      document.getElementById('appCount').textContent = apps.size
    }
    
    // Render node list
    function renderNodeList() {
      const list = document.getElementById('nodeList')
      const activeFilter = document.querySelector('.filter-chip.active').dataset.type
      const search = document.getElementById('searchBox').value.toLowerCase()
      
      const filtered = nodes.filter(node => {
        if (activeFilter !== 'all' && node.type !== activeFilter) return false
        if (search && !node.title.toLowerCase().includes(search)) return false
        return true
      })
      
      list.innerHTML = filtered.map(node => {
        const config = nodeTypes[node.type]
        return `
          <div class="node-item ${selectedNode === node.id ? 'selected' : ''}" data-node-id="${node.id}">
            <div class="node-type" style="background: ${config.color};">
              ${config.icon} ${node.type}
            </div>
            <div class="node-title">${node.title}</div>
            <div class="node-preview">${node.content.slice(0, 50)}</div>
          </div>
        `
      }).join('')
      
      // Add click handlers
      list.querySelectorAll('.node-item').forEach(item => {
        item.addEventListener('click', () => {
          selectedNode = item.dataset.nodeId
          renderNodeList()
          
          // Center on selected node
          const node = nodes.find(n => n.id === selectedNode)
          if (node) {
            camera.x = canvas.width / 2 - node.x * camera.zoom
            camera.y = canvas.height / 2 - node.y * camera.zoom
            render()
          }
        })
      })
    }
    
    // Filter chips
    document.querySelectorAll('.filter-chip').forEach(chip => {
      chip.addEventListener('click', () => {
        document.querySelectorAll('.filter-chip').forEach(c => c.classList.remove('active'))
        chip.classList.add('active')
        renderNodeList()
      })
    })
    
    // Search
    document.getElementById('searchBox').addEventListener('input', renderNodeList)
    
    // AI Analysis
    document.getElementById('aiBtn').addEventListener('click', () => {
      document.getElementById('aiPanel').classList.toggle('active')
    })
    
    document.getElementById('aiInput').addEventListener('keydown', async (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault()
        
        const query = e.target.value.trim()
        if (!query) return
        
        const responseEl = document.getElementById('aiResponse')
        responseEl.innerHTML = '<span class="loading">Analyzing graph...</span>'
        
        try {
          // Prepare graph summary for AI
          const summary = {
            nodeCount: nodes.length,
            edgeCount: edges.length,
            types: Object.entries(
              nodes.reduce((acc, n) => {
                acc[n.type] = (acc[n.type] || 0) + 1
                return acc
              }, {})
            ),
            recentNodes: nodes
              .sort((a, b) => b.timestamp - a.timestamp)
              .slice(0, 5)
              .map(n => ({ type: n.type, title: n.title }))
          }
          
          const prompt = `
            Analyze this knowledge graph:
            ${JSON.stringify(summary, null, 2)}
            
            User question: ${query}
            
            Provide insights about their knowledge graph.
          `
          
          const response = await OS.ai.complete(prompt, {
            provider: 'anthropic',
            maxTokens: 500
          })
          
          responseEl.textContent = response
          
        } catch (error) {
          responseEl.textContent = `Error: ${error.message}`
        }
      }
    })
    
    // Export graph
    document.getElementById('exportBtn').addEventListener('click', () => {
      const data = {
        nodes: nodes.map(n => ({
          id: n.id,
          type: n.type,
          title: n.title,
          content: n.content,
          timestamp: n.timestamp
        })),
        edges: edges,
        metadata: {
          exported: new Date().toISOString(),
          version: '1.0'
        }
      }
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' })
      const url = URL.createObjectURL(blob)
      
      const a = document.createElement('a')
      a.href = url
      a.download = `memory-graph-${Date.now()}.glyphgraph`
      a.click()
      
      URL.revokeObjectURL(url)
    })
    
    // Sync button
    document.getElementById('syncBtn').addEventListener('click', syncFromApps)
    
    // Expose IPC methods
    OS.ipc.expose('addNode', (type, data) => {
      const node = {
        id: `custom-${Date.now()}`,
        type: type || 'custom',
        title: data.title || 'Untitled',
        content: data.content || '',
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: 0,
        vy: 0,
        timestamp: Date.now()
      }
      
      nodes.push(node)
      updateStats()
      renderNodeList()
      render()
      
      return node.id
    })
    
    OS.ipc.expose('query', (filter = {}) => {
      return nodes.filter(node => {
        if (filter.type && node.type !== filter.type) return false
        if (filter.search && !node.title.toLowerCase().includes(filter.search.toLowerCase())) return false
        return true
      })
    })
    
    // Initialize
    syncFromApps()
  </script>
</body>
</html>
